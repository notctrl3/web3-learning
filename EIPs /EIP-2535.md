## [EIP-2535](https://eips.ethereum.org/EIPS/eip-2535):Diamonds, Multi-Facet Proxy

### Motivation                            
 - 允许单个合约地址拥有无限的功能，通过组合多个称为"切面（Facet）"的合约来实现
 - 突破 24KB 合约大小限制（当一个合约编译后的机器码超过 24KB 时，部署到以太坊主网时会失败）
 - 组织不同切面并共享数据，Diamond 中统一管理状态，Facets 可独立或共享
 - 升级机制，可以增加、替换、移除 Facet
 - 可变与不可变选择，可以在部署后将 Diamond 设置为不可升级
 - 可重用已部署的合约，同一 Facet 可被多个 Diamond 使用
### Specification
#### Diamond（主合约）
 - 统一接口：对外暴露所有功能
 - delegatecall 执行 Facet 的函数
 - 统一存储：所有状态都在 Diamond contract 中
#### Facet（切面）
 - 无状态：自身不存储状态
 - 纯逻辑：只包含函数实现
 - 可重用：同一个 Facet 可以被多个 Diamond 使用
 - 对外提供功能：外部函数供调用
#### Loupe Facet
  - 提供 自省（introspection）功能
  - 可以查询 Diamond 的结构（哪些 Facet 有哪些函数）
### Fallback Function
  - Diamond 的 fallback 函数根据 msg.sig（函数选择器）找到对应 Facet
  - 用`delegatecall`调用 Facet 的函数
  - 返回值或错误都会原样返回给调用者
#### example：
``` solidity
// Find facet for function that is called and execute the
// function if a facet is found and return any value.
fallback() external payable {
  // get facet from function selector
  address facet = selectorTofacet[msg.sig];
  require(facet != address(0));
  // Execute external function from facet using delegatecall and return any value.
  assembly {
    // copy function selector and any arguments
    calldatacopy(0, 0, calldatasize())
    // execute function call using the facet
    let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
    // get any return value
    returndatacopy(0, 0, returndatasize())
    // return any return value or error back to the caller
    switch result
      case 0 {revert(0, returndatasize())}
      default {return (0, returndatasize())}
  }
}
```
### Storage
 - ERC-2535 不强制具体存储模式，只说明必须有可预测布局。
   - 常用模式：
     - Diamond Storage → 每个 Facet 在主合约中有独立的 slot（位置）
     - AppStorage → 把所有共享数据放在一个 struct 里，再映射到固定位置
 - 不同 Facet 可以独立使用自己的状态，也可以共享状态
 - 共享状态靠 struct / slot 约定，避免冲突
 - 共享功能靠继承或者 library
### Application
[diamond-3](https://github.com/mudgen/diamond-3/blob/master/contracts/Diamond.sol)
