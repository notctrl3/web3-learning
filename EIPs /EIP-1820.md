## [EIP-1820](https://eips.ethereum.org/EIPS/eip-1820):Pseudo-introspection Registry Contract

### Motivation                            
 传统的Pseudo-introspection方法，例如ERC165不适用与普通账户，而ERC672采用ENS（Ethereum Name Service，链上DNS）又太过麻烦且非中心化
### Specification
#### [ERC1820Registry.sol](https://github.com/0xjac/ERC1820/blob/master/contracts/ERC1820Registry.sol)
#### 状态变量 & 数据结构
| 字段 / mapping 名称                                            | 含义 / 用途                                                                                                                                   |
| ---------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `mapping(address ⇒ address) managers`                      | 对于某个 `account`，谁是它的 “manager”（管理员）——只有 manager 才能为这个 account 设置接口 (interface) 的 implementer。初始 manager 是 account 自己 |
| `mapping(address ⇒ mapping(bytes32 ⇒ address)) interfaces` | 表示某 `account` 对 `interface` 的声明 —— 这个接口由哪个 `implementer` 合约实际实现 |
| `mapping(address ⇒ mapping(bytes4 ⇒ bool)) erc165Cached`   | 用来缓存针对 ERC-165 接口查询的结果|
#### 核心函数
| 函数                                                                                                   | 功能 / 作用                                                                                                                                                                                                                                                                                                                         |
| ---------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `interfaceHash(string calldata interfaceName) public pure returns (bytes32)`                         | 把一个接口名称转成bytes32的`interfaceHash`                                                                                                                                                                                                 |
| `setManager(address account, address newManager) external`                                           | 设置 (或转移) 某个 `account` 的管理员。只有当前管理员才能改。默认 manager 是 account 自己                                                                                                                                                                                          |
| `getManager(address account) external view returns (address)`                                        | 查看某个 account 的当前 manager。方便合约 / 外部判断谁有权限设置 interface                                                                                                                                                                                                                                                   |
| `setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external`      | **核心注册接口** — 对 `account` 来说，它对 `interfaceHash` 接口的实现由 `implementer` 合约负责。注意：<ul><li>如果 `account == address(0)`，代表 caller 自己。</li><li>如果 `implementer == address(0)`，代表移除之前注册。</li><li>`interfaceHash` 不能是 ERC-165 那种 (即不能是后 28 bytes 全 0 的 hash)。</li></ul> 这就允许账户 (EOA 或合约) 声明它支持某个接口 / 能力，即使它本身没代码 |
| `getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address)`    | 查询注册表 —— 看 `account` 是否对 `interfaceHash` 有 implementer。如果之前注册过，就返回 implementer。<br>如果 `interfaceHash` 是 ERC-165 类型 (后 28 bytes 0)，registry 会 fallback → 调目标合约 `supportsInterface(interfaceId)` (即 ERC-165 检查) → 然后返回结果或 0                                                                               |
| `implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool)`        | 检查 `account` 合约 (必须是合约) 是否实现 ERC-165 接口 `interfaceId`。如果在 cache 里有记录，就用 cache;否则去调用 `supportsInterface` 判断是否实现                                                                                                                                                         |
| `implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool)` | 不使用 cache，**立即**用 `staticcall` 检查 `supportsInterface`。适合第一次检测或者当你怀疑 cache 失效时用                                                                                                                                                                                                                              |
| `updateERC165Cache(address account, bytes4 interfaceId) external`                                    | 手动更新 cache。对于 ERC-165 常用接口 (如 ERC-721, ERC-777)，可以在部署 / 初始化时调用一次。这样后续检查会更便宜 (gas 少)，因为用缓存                                                                                                                                                                                                                   |

 - setInterfaceImplementer 只能注册 非 ERC-165 接口。如果你试图注册 ERC-165 interface id (后面补 0) 会被拒绝。防止语义冲突，即防止同一个 interfaceId 同时存在“声明式真理”和“推断式真理（ERC165-supportsInterface）” 
 - 对于 ERC-165 接口的检测，如果你不更新 cache / cache 过期 / 合约升级了 supportsInterface，cached 结果可能过期 → 需要手动 updateERC165Cache。
 - implementer 的正确性 / 安全性留给开发者保证。registry 只记录声明，不校验实现逻辑 (只是 require implementer 遵守 IERC1820Implementer 的 canImplementInterfaceForAddress 返回正确 magic value)。如果 implementer 写得有 bug / 后门，就可能被滥用。
 - 一个全链唯一registry 地址，方便跨链 / 测试网 /主网都兼容

### Application
[ERC1820Registry.sol](https://github.com/0xjac/ERC1820/blob/master/contracts/ERC1820Registry.sol)
