## EIP-2612

### Motivation                            
 ERC20 token在evm里面已经普遍存在了，用户对包含erc20的交易第一步都必须先`approve`只能合约，EIP-2612通过扩展EIP-20 permit(),只需链下
 签名实现对合约的token使用权限授予，减少gas fee和交易次数提高用户体验
### Specification
 除了EIP-20之外，还需实现三个新的函数
 ```
 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external
 function nonces(address owner) external view returns (uint)
 function DOMAIN_SEPARATOR() external view returns (bytes32)
```
#### permit
(v, r, s) 是 owner 对以下消息的有效签名：
```
keccak256(
    abi.encodePacked(
        "\x19\x01",
        DOMAIN_SEPARATOR,
        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))
    )
)
```
- allowance[owner][spender] = value

- nonces[owner] += 1

- 触发 Approval 事件
- \x19\x01 是固定前缀，用来区分 EIP-191 风格签名

- domainSeparator 是合约上下文信息（name/version/chainId/address）

- structHash 是 typed struct 哈希（例如 Permit）
   
For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s, a call to permit(owner, spender, value, deadline, v, r, s) will set allowance[owner][spender] to value, increment nonces[owner] by 1, and emit a corresponding Approval event, if and only if the following conditions are met:

- The current blocktime is less than or equal to deadline.
- owner is not the zero address.
- nonces[owner] (before the state update) is equal to nonce.
- r, s and v is a valid secp256k1 signature from owner of the message:
If any of these conditions are not met, the permit call must revert.

#### DOMAIN_SEPARATOR
```
DOMAIN_SEPARATOR = keccak256(
    abi.encode(
        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
        keccak256(bytes(name)),
        keccak256(bytes(version)),
        chainid,
        address(this)
));
```
#### nonces
For replay protection
### Security Considerations
#### permit owner != address(0)
`ecrecover`在给定无效签名或错误格式时不会抛错，而是返回 address(0)。如果合约仅根据`crecover`的返回值来设置 allowance，而没有检查`owner != address(0)`，则可能把`owner == 0x0`的“授权”记录下来——即批准 spender 可以花 0x0 地址的代币（实际上不存在，但造成逻辑混乱)
#### Frontrunning Attacks
攻击者可以通过抢跑来执行交易，但签名者的最终意图（授权 spender）已经实现
#### Signed Permit messages are censorable
若用户将签名交给 relayer：
- Relay 可以选择不提交（审查）
- deadline 可以减小影响
- 若用户持有 ETH，可自行提交，使旧签名失效
#### Multiple Withdrawal Attack
仍存在用户在修改allowance被多次恶意提现的问题，用`increaseAllowance / decreaseAllowance`做加减而不是覆盖，避免front run造成的损失
#### Chain Split
链分叉后，若两条链`chainId`一样会造成重放攻击  
